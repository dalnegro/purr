% version: 1
% pass: true

function main() {
  // If
  if a then b else c;

  // Pipe
  a |> b |> c;

  // Binary
  a === b;
  a =/= b;
  a >= b;
  a >> b;
  a > b;
  a <= b;
  a << b;
  a < b;
  a ++ b;
  a + b;
  a - b;
  a ** b;
  a * b;
  a / b;
  a and b;
  a or b;
  b in a;

  // Unary
  not a;

  // Call
  a();
  a(b, c, d);
  a(a, ...b);
  a(...b);

  // Send
  a.a();
  a.a(b, c, d);
  a.a.a.a.a(b, c, d);
  a[a].a[a](b, c, d);
  a.a(a, ...b);
  a.a(...b);

  // Update
  a.a().b <- c;
  a.a()[b] <- c;

  a.a <- b;
  a[a] <- b;

  a <- b;

  // Property
  a.b.c.d;
  a[b].c[d];

  // New
  new a.b.c.d(a, b, c);
  new a.b();
  new a(a, ...b);
  new a(...b);

  // Variables
  foo;

  // Values
  1_000;
  1_000.000_000;
  0xcafe_cafe;
  0o123;
  0b1010101;
  -1_000;
  +1_000;
  -1_000.000_000;
  +1_000.000_000;

  "some string \n foo \u0032";
  """some raw string""";
  
  "this
   can
   have
   newlines";

  """this
     too
     can
     have
     newlines""";

  [1, "foo", a];
  [a, ...b];
  { a: b, c: d };

  () => { };
  (a, b, c) => { };
  *(a, b) => { };
  async (a, b) => { };

  () => a;
  (a, b, c) => a;
  *(a, b) => a;
  async (a, b) => a;

  (a);

  // Holes
  _ + a;
  a === _;
  f(_);
  f(a, ..._);
  new f(_);
  not _;
  a.b(c, _);
  a[b](_);
}

function* gen() {
  yield a;
  yield* a;
}

function async prom() {
  await a;
}

function class_expression() {
  let c = class A() {
    constructor;

    /* Documentation */
    static _.f() { }
    static _.f(a, b) { }
    static async _.f() { }
    static* _.f() { }
    static _.f <- g { }
    static _.f { }
    static _[a] { }
    static _[a] <- b { }
    static a === b { }
    static a =/= b { }
    static a >= b { }
    static a >= b { }
    static a >> b { }
    static a > b { }
    static a << b { }
    static a < b { } 
    static a ++ b { }
    static a + b { }
    static a - b { }
    static a ** b { }
    static a * b { }
    static a / b { }
    static a and b { }
    static a or b { }
    static not a { }

    /* Documentation */
    member _.f() { }
    member _.f(a, b) { }
    member async _.f() { }
    member* _.f() { }
    member _.f <- g { }
    member _.f { }
    member _[a] { }
    member _[a] <- b { }
    member a === b { }
    member a =/= b { }
    member a >= b { }
    member a >= b { }
    member a >> b { }
    member a > b { }
    member a << b { }
    member a < b { } 
    member a ++ b { }
    member a + b { }
    member a - b { }
    member a ** b { }
    member a * b { }
    member a / b { }
    member a and b { }
    member a or b { }
    member not a { }  
  };
}

// Named
function test_named() {
  f(a, b: 1, c: 2);
  f(b: 1, c: 2);
  new f(a, b: 1, c: 2);
  new f(b: 1, c: 2);
  a.f(a, b: 1, c: 2);
  a.f(b: 1, c: 2);
}