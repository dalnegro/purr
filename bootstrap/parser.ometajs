function notReserved(x) {
  const re = /^(import|as|exposing|define|end|where|assert|law|forall|async|await|generator|yield|union|abstract|class|extends|implements|let|mutable|include|without|renaming|member|static|export|match|with|if|then|else|do|foreach|of|repeat|from|to|by|break|continue|try|catch|case|const|debugger|default|delete|enum|finally|for|function|in|instanceof|new|return|super|throw|switch|this|typeof|var|void|while|interface|package|private|protected|public|required|optional|override|protocol|implement|and|or|not|field)$/;

  return !re.test(x);
}

function fixReturn(xs) {
  if (xs.length === 0)  return xs;

  const head = xs.slice(0, -1);
  const tail = xs[xs.length - 1];

  switch (tail[0]) {
    case 'expr': {
      const [_, expr] = tail;
      return [...head, ['return', expr]];
    }

    case 'tryfin': {
      const [_, block, fin] = tail;
      return [...head, ['tryfin', fixReturn(block), fin]];
    }

    case 'try': {
      const [_, block, n, err, fin] = tail;
      return [...head, ['try', fixReturn(block), n, fixReturn(err), fin]];
    }

    default:
      return [...head, tail];
  }
}

ometa OrigamiParser {
  idstart    = letter | '_',
  idrest     = idstart | digit,
  name       = <idstart idrest*>,
  identifier = name:id ?notReserved(id),
  integer    = <'-'? digit (digit | '_')*>:x -> x.replace(/_/, ''),
  float      = <'-'? integer '.' integer>:x -> x.replace(/_/, ''),
  boolean    = kw("true") | kw("false"),
  infix      = (seq('===') | seq('=/=') | '>' | seq('>=') | seq('<') | seq('<=') | '+' | '-' | '*' | '/' | seq('and') | seq('or')):a,
  
  stringEscape = '\\' ( 'b' -> '\b'
               | 'f' -> '\f'
               | 'n' -> '\n'
               | 'r' -> '\r'
               | 't' -> '\t'
               | char),
  stringChar = stringEscape:a       -> a
             | (~seq('"') char):a   -> a,
  text       = '"' stringChar*:as '"' -> as.join(''),

  kw :xs = seq(xs) ~(letter | digit),
  listOf :p :s = apply(p):h (_ seq(s) _ apply(p))*:tl -> [h].concat(tl)
               | empty                                -> [],

  comment = fromTo('#', '\n'),
  wspace = /\s/,
  _ = (wspace | comment)*,
  eof = ~char,

  Header = '%' /[^\n\r]/*,

  // Syntactical structure
  Module =
    (_ Header*) _
    (_ Definition)*:ds _ eof -> ['module', ds],

  Definition =
    Union
  | Import
  | Define
  | Interface
  | ClassDef,
  
  // Definitions
  Import =
    kw('import') _ text:id _ kw('as') _ identifier:i -> ['import', id, i],

  Union =
    kw('export')? _ kw('union') _ identifier:n _ TypeArgs?:t (_ UnionVariant)+:vs -> ['union', n, t || [], vs],

  UnionVariant =
    kw('case') _ identifier:n _ VariantArgs:a -> ['case', n, a]
  | kw('case') _ identifier:n                 -> ['case', n, []],

  Define =
    kw('export')? _ kw('define') _ FunDef:f -> ['define', f],

  Interface =
    kw('export')? _ kw('interface') _ identifier:n _ TypeArgs?:t (_ InterfaceDef)+:xs _ kw('end') -> ['iface', n, t, xs],

  InterfaceDef =
    kw('required') _ MemberTypeDecl:m -> ['required', m]
  | kw('optional') _ MemberTypeDecl:m -> ['optional', m]
  | kw('include') _ TypeDef:t -> ['include', t],

  ClassDef =
    kw('export')? _ kw('class')
    _ identifier:n _ TypeArgs?:t _ FnParams:p
    (_ kw('extends') _ Expr)?:e
    (_ Stmt)*:c
    (_ kw('with'))
    (_ ClassMemberDecl)*:xs
    _ kw('end') -> ['class', n, t, p, e || 'none', c, xs],
  
  ClassMemberDecl =
    kw('implements') _ TypeDef:t -> ['impl', t]
  | kw('mutable')?:m _ kw('field') _ identifier:i (_ seq('::') _ TypeDef)?:t -> ['field', m, i, t]
  | MemberVisibility:v _ kw('member') _ MemberDecl:m -> ['member', v, m]
  | MemberVisibility:v _ kw('static') _ StaticMemberDecl:m -> ['static', v, m],

  MemberVisibility =
    kw('private')
  | kw('protected')
  | kw('public')
  | empty -> 'public',

  MemberDecl =
    MethodDef:m -> ['meth', m]
  | Param:s _ '.' _ identifier:i _ seq('<-') _ Param:v _ RawBody:b -> ['set', s, i, v, b]
  | Param:s _ '.' _ identifier:i _ Body:b -> ['get', s, i, b],

  StaticMemberDecl =
    FunDef:f -> ['fun', f]
  | identifier:i _ seq('<-') _ Param:v _ RawBody:b -> ['set', i, v, b]
  | identifier:i _ Body:b -> ['get', i, b],

  MethodDef =
    DefineType?:t _ Param:l _ infix:op _ Param:r _ Body:b -> [t, op, l, [r], b]
  | DefineType?:t _ kw('not') _ Param:p _ Body:b -> [t, 'not', p, [], b]
  | DefineType?:t _ Param:s _ '.' _ identifier:i _ FnParams:p _ Body:b -> [t, i, s, p, b],

  FunDef =
    DefineType?:t _ Param:l _ infix:op _ Param:r _ Body:b -> [t, op, [l, r], b]
  | DefineType?:t _ kw('not') _ Param:p _ Body:b -> [t, 'not', [p], b]
  | DefineType?:t _ identifier:i _ FnParams:p _ Body:b -> [t, i, p, b],

  MemberTypeDecl =
    kw('not') _ SelfType:s _ RetParam:r -> ['fn', s, 'not', [], r]
  | kw('new') _ FnParams:p _ RetParam:r -> ['new', p, r]
  | SelfType:s _ '.' _ identifier:i _ FnParams:p _ RetParam:r -> ['fn', s, i, p, r]
  | SelfType:s _ '.' _ identifier:i (_ seq('::') _ TypeDef)?:t -> ['prop', s, i, t || ['type-any']]
  | SelfType:s _ '[' _ TypeDef:t _ ']' (_ seq('::') _ TypeDef)?:r -> ['at', s, t, r || ['type-any']]
  | SelfType:s _ infix:op _ Param:p _ RetParam:r -> ['fn', s, op, [p], r], 

  VariantArgs =
    '(' _ Param:v (_ ',' _ Param)*:vs _ ')' -> [v].concat(vs),

  TypeArgs =
    '<' _ TypeDef:t (_ ',' _ TypeDef)*:ts _ '>' -> [t].concat(ts),

  TypeDef =
    '\'' identifier:i                                         -> ['type-var', i]
  | identifier:i _ TypeArgs:ts                                -> ['type-app', i, ts]
  | identifier:i                                              -> ['type-ref', i]
  | seq('any')                                                -> ['type-any']
  | '(' _ listOf('TypeDef'):i _ ')' _ seq('->') _ TypeDef:o   -> ['type-fn', i, o],

  SelfType =
    identifier:n (_ seq('::') _ TypeDef)?:t -> [n, t || ['type-any']],

  Param =
    identifier:i _ seq('::') _ TypeDef:t -> [i, t]
  | identifier:i                         -> [i, ['type-any']],

  DefineType = kw('async') | kw('generator'),

  FnParams = '(' _ listOf(#Param, ','):ps _ ')' -> ps,

  RetParam =
    seq('->') _ TypeDef:t -> t
  | empty -> ['type-any'],


  // Expressions
  Body = RawBody:b -> fixReturn(b),

  RawBody =
    '=' _ Expr:e         -> [['expr', e]]
  | Stmts:xs _ kw('end') -> xs,


  Stmts = (_ Stmt)+,

  Stmt =
    Let
  | Loop
  | Try
  | Throw
  | Assert
  | Expr:e _ ';' -> ['expr', e],

  Block = kw('do') _ Stmts:xs _ kw('end') -> xs,

  Loop =
    kw('foreach') _ identifier:v _ kw('of') _ Expr:e _ Block:b -> ['foreach', v, e, b]
  | kw('repeat') _ kw('while') _ Expr:e _ Block:b -> ['while', e, b]
  | kw('repeat') _ kw('until') _ Expr:e _ Block:b -> ['until', e, b]
  | kw('repeat') _ kw('with') _ identifier:n _ kw('from') _ Expr:s _ kw('to') _ Expr:e (_ kw('by') _ Expr)?:k _ Block:b -> ['for', n, s, e, k || 1, b]
  | kw('repeat') _ Stmts:b _ kw('end') -> ['repeat', b],

  Try =
    kw('try') _ Stmts:b _ kw('finally') _ Stmts:f _ kw('end') -> ['tryfin', b, f]
  | kw('try') _ Stmts:b _ kw('catch') _ identifier:n _ kw('with') _ Stmts:c (_ kw('finally') _ Stmts)?:f _ kw('end') -> ['try', b, n, c, f || 'none'],

  Throw =
    kw('throw') _ Expr:e _ ';' -> ['throw', e],

  Assert =
    kw('assert') _ Expr:e _ ';' -> ['assert', e],

  Let =
    kw('let') _ kw('mutable')?:m _ identifier:n _ '=' _ Expr:v _ ';' -> ['let', m || '', n, v],

  Expr = 
    If
  | Pipe,

  If =
    kw('if') _ Expr:a _ kw('then') _ Expr:b _ kw('else') _ Expr:c -> ['if', a, b, c],

  Pipe =
    Pipe:l _ seq('|>') _ Logical:r -> ['pipe', l, r]
  | YieldAwait,

  YieldAwait =
    kw('await') Logical:l -> ['await', l]
  | kw('yield') _ '*' _ Logical:l -> ['yield*', l]
  | kw('yield') Logical:l -> ['yield', l]
  | Logical,

  Logical = 
    Logical:l _ (kw('and') | kw('or')):op _ Relational:r -> ['opcall', op, [l, r]]
  | Infix,

  Infix =
    Infix:l _ '`' _ PrimaryExpr:n _ Relational:r -> ['call', n, [r]]
  | Relational,

  Relational =
    Relational:l _ (seq('===') | seq('=/=') | seq('>=') | seq('<=') | '<' | '>'):op _ Add:r -> ['opcall', op, [l, r]]
  | Add,

  Add =
    Add:l _ ('+' | '-'):op _ Mul:r -> ['opcall', op, [l, r]]
  | Mul,

  Mul =
    Mul:l _ ('*' | '/'):op _ Unary:r -> ['opcall', op, [l, r]]
  | Unary,

  Unary =
    kw('not') _ Relational:r -> ['opcall', 'not', [r]]
  | Call,

  Call =
    Call:callee _ '(' _ listOf(#Expr, ','):args _ ')' -> ['call', callee, args]
  | PostfixCall,

  PostfixCall =
    PostfixCall:p _ '.' _ name:n _ '(' _ listOf(#Expr, ','):args _ ')' -> ['send', p, n, args]
  | Postfix,

  Postfix =
    Postfix:p _ '.' _ name:n _ seq('<-') _ Expr:e -> ['setprop', p, n, e]
  | Postfix:p _ '[' _ Expr:k _ ']' _ seq('<-') _ Expr:e -> ['putat', p, k, e]

  | Postfix:p _ '.' _ name:n -> ['get', p, n]
  | Postfix:p _ '[' _ Expr:e _ ']' -> ['at', p, e]
  
  | PrimaryExpr:p _ seq('<-') _ Expr:e -> ['set', p, e]
  | kw('new') _ Postfix:p _ '(' _ listOf(#Expr, ','):args _ ')' -> ['new', p, args]
  | kw('super') _ '.' _ name:n _ '(' _ listOf(#Expr, ','):args _ ')' -> ['send', ['ref', 'super'], n, args]
  | kw('super') _ '(' _ listOf(#Expr, ','):args _ ')' -> ['call', ['ref', 'super'], args]
  | PrimaryExpr,

  PrimaryExpr =
    Do
  | Lambda
  | Literal
  | identifier:i -> ['ref', i]
  | '(' _ Expr:e _ ')' -> e,

  Lambda =
    '(' _ listOf(#Param, ','):p _ ')' _ seq('=>') _ Expr:e -> ['fn', p, e],

  NumericLiteral =
    float:n 'f' -> ['lit_float', n]
  | float:n -> ['lit_dec', n]
  | integer:n -> ['lit_int', n],

  Literal =
    boolean:b -> ['lit_bool', b]
  | NumericLiteral
  | text:s -> ['lit_str', s]
  | seq('[|') _ listOf(#Expr, ','):e _ seq('|]') -> ['array', e]
  | '[' _ listOf(#Pair, ','):e _ ']' -> ['map', e]
  | '[' _ listOf(#Expr, ','):e _ ']' -> ['vector', e]
  | '{' _ listOf(#Pair, ','):e _ '}' -> ['record', e],

  Pair =
    name:n _ ':' _ Expr:e -> [n, e],

  Do =
    kw('do') _ Stmts:b _ kw('end') -> ['do', fixReturn(b)]
}