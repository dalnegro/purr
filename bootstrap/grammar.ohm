Origami {
  Program
    = Header* Definition* end

  Header
    = "%" line

  Definition
    = Import
    | Export
    | Function
    | Class
    | Module
    | Union
    | Statement  -- stmt


  // ## Imports
  Import
    = import_ String as_ Name ";"                                   -- as
    | import_ String exposing_ NonemptyListOf<Binding, ","> ";"     -- exposing
    | import_ Name exposing_ NonemptyListOf<Binding, ","> ";"       -- core

  Binding
    = Name as_ Name       -- aliased
    | default_ as_ Name   -- default
    | Name                -- original

  // ## Exports
  Export
    = export_ Name as_ Name ";"   -- aliased
    | export_ Name ";"            -- original

  // ## Functions
  Function
    = Metadata? function_ FunctionSignature FunctionBody

  FunctionBody
    = "=" Expression ";"    -- expr
    | Block                 -- block

  FunctionSignature
    = FunctionType? Name ParamList ReturnContract?

  ParamList
    = "(" "..." ParamName ")"                                                       -- only_spread
    | "(" NonemptyListOf<ParamName, ","> "," "..." ParamName ")"                    -- pos_spread
    | "(" NonemptyListOf<NamedParam, ","> ")"                                       -- only_named
    | "(" NonemptyListOf<ParamName, ","> "," NonemptyListOf<NamedParam, ","> ")"    -- pos_named
    | "(" ListOf<ParamName, ","> ")"                                                -- only_pos

  ParamName
    = Name NameContract    -- checked
    | Name ~":"            -- unchecked

  PParamName
    = "(" Name NameContract ")"  -- checked
    | Name ~":"                  -- unchecked

  PParamNames
    = NonemptyListOf<PParamName, ",">

  NamedParam
    = Name ":" ParamName "=" Expression    -- with_default
    | Name ":" ParamName                   -- no_default

  ReturnContract
    = "->" TypeExpression

  NameContract
    = "::" TypeExpression

  TypeExpression
    = QualifiedName "<" NonemptyListOf<TypeExpression, ","> ">" -- apply
    | QualifiedName                                             -- name

  FunctionType
    = "*"     -- generator
    | async_  -- async


  // ## Modules
  Module
    = Metadata? module_ Name "{" Definition* "}"


  // ## Classes
  Union
    = Metadata? UnionDeclaration

  UnionDeclaration
    = union_ Name "{" UnionCase+ "}"

  UnionCase
    = Metadata? case_ Name ParamList ";"


  Class
    = Metadata? ClassDeclaration

  ClassDeclaration
    = data_? class_ Name ParamList SuperClass? "{" ClassField* Statement* ClassMember* "}"

  SuperClass
    = extends_ MemberExpression ArgList

  ClassField
    = Metadata? mutable_? field_ Name NameContract? "=" Expression ";"

  ClassMember
    = Metadata? static_ MemberDeclaration    -- static
    | Metadata? member_ MemberDeclaration    -- instance

  MemberDeclaration
    = FunctionType? PParamName "." Name ParamList ReturnContract? MemberBlock     -- method
    | PParamName "." Name "<-" PParamName ReturnContract? MemberBlock             -- setter
    | PParamName "." Name ReturnContract? MemberBlock                             -- getter
    | PParamName "[" PParamNames "]" "<-" PParamName ReturnContract? MemberBlock  -- atput
    | PParamName "[" PParamNames "]" ReturnContract? MemberBlock                  -- at
    | PParamName in_ PParamName ReturnContract? MemberBlock                       -- in
    | PParamName operator PParamName ReturnContract? MemberBlock                  -- operator
    | not_ PParamName ReturnContract? MemberBlock                                 -- not
  
  MemberBlock
    = "=" Expression ";"    -- expr
    | Block                 -- block

  String
    = #"\"\"\"" #raw_character* #"\"\"\""       -- raw
    | #"\"" #string_character* #"\""            -- double
  
  Integer
    = #"-" #integral_number   -- negative
    | #"+" #integral_number   -- positive
    | integral_number         -- unsigned

  Decimal
    = #"-" #decimal_digit+ #"." #decimal_digit+   -- negative
    | #"+" #decimal_digit+ #"." #decimal_digit+   -- positive
    | ~ "_" #decimal_digit+ #"." #decimal_digit+  -- unsigned
  
  Boolean
    = true_    -- true
    | false_   -- false

  Metadata
    = DocComment
    
  DocComment
    = doc_comment

  Block
    = "{" Statement* "}"

  Statement
    = LetStatement
    | AssertStatement
    | LoopStatement
    | IfStatement
    | MatchStatement
    | Expression ";"    -- expression

  LetStatement
    = let_ mutable_? Name NameContract? "=" Expression ";"      -- bind
    | let_ Pattern "=" Expression ";"             -- destructure

  AssertStatement
    = assert_ Expression ";"

  LoopStatement
    = for_ each_ Name of_ Expression Block                                      -- foreach
    | repeat_ while_ Expression Block                                           -- while
    | repeat_ until_ Expression Block                                           -- until
    | repeat_ with_ Name from_ Expression to_ Expression Block                  -- for
    | repeat_ with_ Name from_ Expression to_ Expression by_ Expression Block   -- for_by
    | repeat_ Block                                                             -- repeat

  IfStatement
    = if_ Expression Block AlternateStatement?

  AlternateStatement
    = else_ IfStatement   -- elseif
    | else_ Block         -- else

  MatchStatement
    = Match

  Match
    = match_ Expression "{" MatchCase* "}"

  MatchCase
    = case_ Pattern when_ Expression ":" Statement*   -- case_when
    | case_ Pattern ":" Statement*                    -- case
    | default_ ":" Statement*                         -- default

  Pattern
    = Literal                                         -- literal
    | "[" ArrayPattern "]"                            -- array
    | "{" ListOf<PairPattern, ","> "}"                -- object
    | MemberExpression "(" ListOf<Pattern, ","> ")"   -- extractor
    | Name                                            -- bind

  ArrayPattern
    = NonemptyListOf<Pattern, ","> "," "..." Pattern  -- spread1
    | "..." Pattern                                   -- spread0
    | ListOf<Pattern, ",">                            -- regular

  PairPattern
    = Name ":" Pattern
    
  
  Expression
    = IfExpression
    | PipeExpression

  IfExpression
    = if_ Expression then_ Expression else_ Expression

  PipeExpression
    = PipeExpression "|>" BinaryExpression  -- pipe
    | YieldAwait

  YieldAwait
    = await_ BinaryExpression       -- await
    | yield_ "*" BinaryExpression   -- yield_all
    | yield_ BinaryExpression       -- yield
    | BinaryExpression

  BinaryExpression
    = UnaryExpression operator UnaryExpression  -- binary
    | UnaryExpression in_ UnaryExpression -- in
    | UnaryExpression
    
  UnaryExpression
    = not_ SendExpression -- not
    | SendExpression

  SendExpression
    = SendExpression SendContinuation   -- send
    | AssignExpression

  SendContinuation
    = ArgList                   -- call
    | "." Name ArgList          -- method_call
    | Property "<-" Expression  -- assign
    | Property                  -- property

  Property
    = "[" Expression "]"    -- at
    | "." Name              -- get

  AssignExpression
    = MemberExpression "<-" Expression  -- assign
    | MemberExpression

  MemberExpression
    = MemberExpression Property   -- member
    | NewExpression

  NewExpression
    = new_ MemberExpression ArgList   -- new
    | PrimaryExpression
  
  PrimaryExpression
    = ~reserved_var Name ~":"           -- variable
    | super_                            -- super
    | "@" QualifiedName Literal         -- plug_literal
    | Literal                           -- literal
    | "_"                               -- hole
    | ArrayExpression                   -- array
    | ObjectExpression                  -- object
    | FunctionExpression                -- function
    | Class                             -- class
    | "(" Expression ")"                -- group

  ArrayExpression
    = mutable_? "[" ListOf<ArrayItem, ","> "]"

  ArrayItem
    = "..." Expression    -- spread
    | Expression          -- item

  ObjectExpression
    = mutable_? "{" ListOf<Pair, ","> "}"

  FunctionExpression
    = FunctionType? ParamList ReturnContract? "=>" Block        -- block
    | FunctionType? ParamList ReturnContract? "=>" Expression   -- expr

  Literal
    = String
    | Boolean
    | Decimal
    | Integer
    | null_                 -- null

  ArgList
    = "(" "..." Expression ")"                                              -- only_spread
    | "(" NonemptyListOf<Expression, ","> "," "..." Expression ")"          -- pos_spread
    | "(" NonemptyListOf<Pair, ","> ")"                                     -- only_named
    | "(" NonemptyListOf<Expression, ","> "," NonemptyListOf<Pair, ","> ")" -- pos_named
    | "(" ListOf<Expression, ","> ")"                                       -- only_pos

  Pair
    = Name ":" Expression

  Name
    = ~reserved id

  QualifiedName
    = NonemptyListOf<Name, ".">

  //-- LEXICAL --------------------------------------------------------
  newline = "\n" | "\r"
  line = (~newline any)*
  comment = "//" line
  doc_comment = "/*" (~"*/" any)* "*/"
  space += comment

  id_start = letter | "_"
  id_rest = id_start | digit
  id = id_start id_rest*

  kw<word> = word ~id_rest
  reserved_var = "_" ~id_rest

  operator 
    = "===" | "=/=" | "==>"
    | ">="  | ">>"  | ">"
    | "<="  | "<<"  | "<"
    | "++"  | "+"
    | "-"
    | "**"  | "*"
    | "/"
    | and_  | or_   | is_


  octal_digit = "0" .. "7" | "_"
  hex_digit = raw_hex_digit | "_"
  raw_hex_digit = "0" .. "9" | "a" .. "f" | "A" .. "F"
  bin_digit = "0" | "1" | "_"
  decimal_digit = "0" .. "9" | "_"

  integral_number 
    = "0o" octal_digit+       -- octal
    | "0x" hex_digit+         -- hex
    | "0b" bin_digit+         -- binary
    | ~"_" decimal_digit+     -- decimal


  raw_character 
    = ~"\"\"\"" any

  escape_sequence
    = "b"                 -- backspace
    | "f"                 -- form_feed
    | "n"                 -- newline
    | "r"                 -- return
    | "t"                 -- tab
    | "u" unicode_escape  -- unicode
    | "\""                -- quote
    | "\\"                -- backslash

  string_character
    = ~("\"" | "\\") any    -- non_escaped
    | "\\" escape_sequence   -- escaped

  unicode_escape 
    = raw_hex_digit raw_hex_digit raw_hex_digit raw_hex_digit



  import_ = kw<"import">
  exposing_ = kw<"exposing">
  as_ = kw<"as">

  function_ = kw<"function">
  async_ = kw<"async">

  data_ = kw<"data">
  class_ = kw<"class">
  abstract_ = kw<"abstract">
  extends_ = kw<"extends">
  static_ = kw<"static">
  member_ = kw<"member">
  field_ = kw<"field">

  let_ = kw<"let">
  mutable_ = kw<"mutable">

  assert_ = kw<"assert">

  if_ = kw<"if">
  then_ = kw<"then">
  else_ = kw<"else">

  and_ = kw<"and">
  or_ = kw<"or">
  not_ = kw<"not">
  
  await_ = kw<"await">
  yield_ = kw<"yield">

  new_ = kw<"new">
  super_ = kw<"super">

  for_ = kw<"for">
  each_ = kw<"each">
  of_ = kw<"of">
  repeat_ = kw<"repeat">
  with_ = kw<"with">
  while_ = kw<"while">
  until_ = kw<"until">
  from_ = kw<"from">
  to_ = kw<"to">
  by_ = kw<"by">

  true_ = kw<"true">
  false_ = kw<"false">

  try_ = kw<"try">
  finally_ = kw<"finally">
  catch_ = kw<"catch">

  match_ = kw<"match">
  case_ = kw<"case">
  when_ = kw<"when">
  default_ = kw<"default">

  null_ = kw<"null">

  module_ = kw<"module">
  export_ = kw<"export">

  in_ = kw<"in">
  is_ = kw<"is">
  union_ = kw<"union">


  reserved
    = abstract_ | and_ | assert_ | async_ | as_ | await_
    | by_
    | case_ | catch_ | class_
    | data_ | default_
    | each_ | else_ | export_ | exposing_ | extends_
    | false_ | field_ | finally_ | for_ | from_ | function_
    | if_ | import_ | in_ | is_
    | let_
    | match_ | member_ | module_ | mutable_
    | new_ | not_ | null_
    | of_ | or_
    | repeat_
    | static_ | super_
    | then_ | to_ | true_ | try_
    | until_ | union_
    | with_ | when_ | while_
    | yield_
}