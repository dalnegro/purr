const g = require('./codegen');

ometa OrigamiCompiler {
  compile =
    [#module [compile_def*:xs]] -> { xs.join('\n\n') },

  compile_def =
    [#union :id :t [variant*:vs]] -> g.Union(id, vs)
  | [#import :id :n] -> { 'import * as ' + n + ' from ' + JSON.stringify(id) + ';' }
  | [#define [:t :n [param*:xs] [stmt*:b]]] -> g.Define(n, t, xs, b)
  | [#iface :n :t [iface_mem*:d]] -> g.Interface(n, t, d)
  | [#class :n :t [param*:p] #none [stmt*:b] [class_mem*:m]] -> g.Class(n, t, p, '', b, m)
  | [#class :n :t [param*:p] expr:e [stmt*:b] [class_mem*:m]] -> g.Class(n, t, p, e, b, m),

  class_mem =
    [#impl :t] -> ['impl', t]
  | [#field :mut :n :t] -> ['field', mut, n, t]
  | [#member :v imem:m] -> ['member', v, m]
  | [#static :v smem:m] -> ['static', v, m],

  imem =
    [#meth [:t :n param:s [param*:xs] [stmt*:b]]] -> ['meth', t, n, s, xs, b]
  | [#set param:s :i param:v [stmt*:b]] -> ['set', s, i, v, b]
  | [#get param:s :i [stmt*:b]] -> ['get', s, i, b],

  smem =
    [#fun [:t :n [param*:xs] [stmt*:b]]] -> ['fun', t, n, xs, b]
  | [#set :i param:v [stmt*:b]] -> ['sset', i, v, b]
  | [#get :i [stmt*:b]] -> ['sget', i, b],

  iface_mem =
    [#include :t] -> ['include', t]
  | [:t iface_def:d] -> [t, d],

  iface_def =
    [#fn :s :n [param*:p] :r] -> [n, '(' + p.join(', ') + ')']
  | [#new [param*:p] :r] -> ['new', '(' + p.join(', ') + ')']
  | [#prop :s :n :t] -> [n, '']
  | [#at :s :t :t2] -> ['', '[k: any]'],

  variant =
    [#case :n [param*:xs]] -> [n, xs],
  
  param =
    [:n :t] -> n,

  stmt =
    [#let #mutable :n expr:v] -> { 'let ' + n + ' = ' + v }
  | [#let :k :n expr:v]       -> { 'const ' + n + ' = ' + v }
  | [#return expr:e]          -> { 'return ' + e }
  | [#foreach :v expr:e [stmt*:b]] -> {
    'for (const ' + v + ' of ' + e + ') {\n'
  + '    ' + b.join('\n    ') + '\n'
  + '  }'
  }
  | [#while expr:e [stmt*:b]] -> {
    'while (' + e + ') {\n'
  + '    ' + b.join('\n    ') + '\n'
  + '  }'
  }
  | [#until expr:e [stmt*:b]] -> {
    'do {\n'
  + '    ' + b.join('\n    ') + '\n'
  + '  } while (' + e + ')'
  }
  | [#for :n expr:s expr:e expr:k [stmt*:b]] -> {
    'for (let ' + n + ' = ' + s + '; $gte(' + n + ', ' + e + '); ' + n + ' = $plus(' + n + ', ' + k + ')) {\n'
  + '    ' + b.join('\n  ') + '\n'
  + '  }'
  }
  | [#repeat [stmt*:b]] -> {
    'while (true) {\n'
  + '    ' + b.join('\n    ') + '\n'
  + '  }'
  }

  | [#tryfin [stmt*:b] [stmt*:f]] -> {
    'try {\n'
  + '    ' + b.join('\n    ') + '\n'
  + '  } finally {\n'
  + '    ' + f.join('\n    ') + '\n'
  + '  }'
  }

  | [#try [stmt*:b] :n [stmt*:c] 'none'] -> {
    'try {\n'
  + '    ' + b.join('\n    ') + '\n'
  + '  } catch (' + n + ') {\n'
  + '    ' + c.join('\n    ') + '\n'
  + '  }'
  }

  | [#try [stmt*:b] :n [stmt*:c] [stmt*:f]] -> {
    'try {\n'
  + '    ' + b.join('\n    ') + '\n'
  + '  } catch (' + n + ') {\n'
  + '    ' + c.join('\n    ') + '\n'
  + '  } finally {\n'
  + '    ' + f.join('\n    ') + '\n'
  + '  }'
  }

  | [#throw expr:e] -> { 'throw ' + e }
  | [#assert expr:e] -> {
    'if (!' + e + ') {\n'
  + '    throw $fail(' + JSON.stringify(e) + ');\n'
  + '  }'
  }

  | [#expr expr:e] -> e,

  expr =
    [#pipe expr:l expr:r] -> { '(' + r + ')(' + l + ')' }
  | [#await expr:l] -> { '(await ' + l + ')' }
  | ['yield*' expr:l ] -> { '(yield* ' + l + ')' }
  | [#yield expr:l] -> { '(yield ' + l + ')' }
  | [#call expr:e [expr*:xs]] -> { '(' + e + ')(' + xs.join(', ') + ')' }
  | [#opcall :n [expr*:xs]] -> { g.mangle(n) + '(' + xs.join(', ') + ')' }
  | [#if expr:a expr:b expr:c] -> { '((' + a + ') ? (' + b + ') : (' + c + '))' }
  | [#match expr:e [matchcase*:ps]] -> g.Match(e, ps)
  | [#set expr:l expr:r] -> { '(' + l + ') = (' + r + ')' }
  | [#setprop expr:l :n expr:r] -> { '(' + l + ')[' + JSON.stringify(n) + '] = (' + r + ')'  }
  | [#putat expr:l expr:k expr:r] -> { '$atput(' + l + ', ' + k + ', ' + r + ')' }
  | [#send expr:c :n [expr*:xs]] -> { '(' + c + ').' + n + '(' + xs.join(', ') + ')' }
  | [#get expr:m :n] -> { '(' + m + ')[' + JSON.stringify(n) + ']' }
  | [#at expr:m expr:i] -> { '$at(' + m + ', ' + i + ')' }
  | [#new expr:p [expr*:xs]] -> { 'new (' + p + ')(' + xs.join(', ') + ')' }
  | [#fn [param*:p] expr:e] -> { 
    '(' + p.map(function(x) { return x + ': any' }).join(', ') + ') => ' + e
  }
  | [#vector [expr*:e]] -> { '$vector(' + e.join(', ') + ')' }
  | [#map [assoc*:xs]] -> {
    '$map('
    + xs.map(function(x){ return '[' + JSON.stringify(x[0]) + ', ' + x[1] + ']' }).join(', ')
    + ')'
  }
  | [#array [expr*:e]] -> {
    '[' + e.join(', ') + ']'
  }
  | [#record [assoc*:xs]] -> {
    '{'
    + xs.map(function(x){ return JSON.stringify(x[0]) + ': ' + x[1] }).join(', ')
    + '}'
  }
  | [#lit_bool :b] -> b
  | [#lit_float :n] -> n
  | [#lit_int :n] -> { '$int(' + JSON.stringify(n) + ')' }
  | [#lit_dec :n] -> { '$dec(' + JSON.stringify(n) + ')' }
  | [#lit_str :s] -> JSON.stringify(s)
  | [#do [stmt*:xs]] -> { '(function(){ ' + xs.join('; ') + ' })' }
  | [#ref :i] -> i,

  matchcase =
    [pattern:p expr:e] -> [p, e],

  pattern =
    [#anything] -> ['any']
  | [#eq expr:e] -> ['eq', e]
  | [#extractor expr:m :p] -> ['extract', m, p]
  | [#bind :i] -> ['bind', i],

  assoc =
    [:n expr:e] -> [n, e]
}