% version: 1
# This is a module

import "runtime" as rt

union Maybe<'a>
  case Just(value :: 'a)
  case Nothing()
end


define foo() =
  match new Maybe.Just(2) with
    case Maybe.Just(value) do value + 1
    case Maybe.Nothing()   do "nope"
  end

define a + b = a |> b |> c

define fold(container, from: start, using: fn) do
  fn(start, fold(container, from: start, using: fn));
end

define fn(a :: Maybe<'a>, f :: ('a) -> 'b) -> a do
  let mutable y = x;
  let x = a + 1;
  foreach x of y do z; end
  repeat while x do z; end
  repeat until x do z; end
  repeat with a from 1 to x by 2 do z; end
  repeat z; end
  try a; finally z; end
  try a; catch e with z; end
  try a; catch e with z; finally b; end
  throw e;
  assert z;

  a |> b;
  f(a, b, c);
  a + x; a or x; a === x; a ++ b;
  if a then b else c;
  a <- b;
  a.c <- b;
  a.c(foo, bar);
  a[c];
  a.b[c].d <- a;
  a.b[c] <- a;
  a[c] <- a;
  new a.c(foo, bar);
  new a();
  (a, b, c) -> a + b + c;
  [a, b, c];
  [a: b, c: d];
  [| a, b, c |];
  { a: b, c: d };
  true; false;
  1_000.03f;
  1_000;
  -10;
  1_000.282;
  "foo";
  a;
  do a; b; end;
end

export interface Foo<'a>
  required self.a
  optional self.b :: b
  include Qux
  required not self -> a
  required self === b -> c
  required self[x] :: q
  required x::a.foo(a :: B, c) -> d
  required new (a :: b) -> r
  required self.foo(a :: number, b: x :: number) -> y
end

export class Foo<'a>() extends Bar.Qux(1)
  let x = 1;
  2 + 3;
  super(a);
with
  implements A<'b>
  implements C<'d>
  
  private member async a.foo(x) = 1
  protected member a and x = 2
  public member generator not x = 3
  member a.test :: number = 4
  member a.test <- val = 5

  member foo(a, kw: x) = 1

  public static foo(x) = 1
  protected static foo and bar = 3
  private static not foo = 4
  static foo = super.foo()
  static foo <- bar = 4
end

class A(b, c)
  let x = b + c;
  self.y <- x;
with
  field y :: Int
end

class B(x, y) with
  member self.x = x
  member self.y = y
end
