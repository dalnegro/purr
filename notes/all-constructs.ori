# Module headers
% version: 1

# Imports
import "'id'"
import "'id'" as binding
import "'id'" exposing (a, b, c as d)

# Definitions
define l + r = body

define foo(a, kw: b, typed :: C) -> ret
  body
end

define f()
  body
where
  assert x ==> y
  law foo(x): blah
end

define async f()
  await foo
  return bar
end

define generator f() 
  yield foo
end


# Data structures
union A
  | foo
  | bar
  | qux
end

# need to allow abstract
class F(...) # <- fields go here
extends C 
implements interface
  # private protected public readonly - modifiers can go before any

  # always private
  let x :: foo = bar
  let mutable x :: foo = bar

  # traits
  include D
  include D without C renaming (a as d)
  # this needs some way of override/extend

  member self.foo(...) -> ret
    expr
  end

  member self.foo = ...
  member self.foo <- v = ...

  static foo = ...
  static bar(...) -> ret = ...
end

export foo

interface Name<'a ...>
  required self.foo(...)
  optional self.foo
end

protocol Name<...>
  required self.foo(...)
  required self.bar(...)
  optional self.bar(...) = impl
  member <same syntax>
end

implement Name<...> for Expr
  member ...
  override ...
end

# Statements
let x = y
let mutable x = y

# Expressions
a and b, a or c, not a

match x with
  | Case(v) -> x
end

if x then y else z

(a, b, c) => d
(a, b, c) => do ... end

f(a, b, c)
f(a, to: b, more: c)
a.foo()
a.qux

a <- b
a.qux <- b

a `at(1)
a |> bar(?, foo)

do ... end # wraps statements in an expression

foreach x of y do ... end
foreach x of y async do ... end

repeat from x to y by z do ... end
repeat ... end

break
continue

try ... catch e with ... finally ... end
throw foo
new Class(...)

# TS reserved words
# break
# case
# catch
# class
# const
# continue
# debugger
# default
# delete
# do
# else
# enum
# export
# extends
# false
# finally
# for
# function
# if
# import
# in
# instanceof
# new
# null
# return
# super
# switch
# this
# throw
# true
# try
# typeof
# var
# void
# while
# with
# as
# implements
# interface
# let
# package
# private
# protected
# public
# static
# yield