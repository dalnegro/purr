% language: origami

import "./ast" as ast;
import es2015 exposing Reflect;

data class Pair(key, value) {}
data class Signature(kind, name, parameters) {}


module Grammar {
  let assocLeft = (initial, xs, f) => {
    let [first, ...rest] = xs;
    rest.reduce(f, f(initial, first));
  };

  let binaryL = (l, ops) => 
    assocLeft(l, ops, (l, x) => new ast.Expression.Binary(l, x.operator, x.expression));

  let sameOperator = (xs) => {
    let [[op, _], ...rest] = xs;
    rest.every((pair) => pair[0] === op);
  };

  let fixDigits = (xs) => {
    let re = new RegExp("_", "g");
    let digits = xs.join("").replace(re, "");
    digits;
  };

  let pairsToObject = (pairs) => {
    let mutable result = {};
    for each pair of pairs {
      Reflect.set(result, pair.key, pair.value);
    }
    result;
  };

  let grammar = <origami.grammar.peg> """
Origami {
  Program
    = h:Header* d:Definition* end    { new ast.File(pairsToObject(h), d); }
    ;

  Header
    = "%" n:id ":" l:line   { new Pair(n, l); }
    ;
  
  Definition
    = Import
    / Export
    / Function
    / Class
    / Module
    / l:LetStatement    { new ast.Definition.Statement(l); }
    ;

  Import
    = m:Meta import_ id:String ";"    
      { new ast.Definition.Import(m, id, null, []); }

    / m:Meta import_ id:String as_ n:Name ";"
      { new ast.Definition.Import(m, id, n, []); }

    / m:Meta import_ id:String exposing_ b:NonemptyListOf<Binding, ","> ";"
      { new ast.Definition.Import(m, id, null, b); }

    / m:Meta import_ id:Name as_ n:Name ";"
      { new ast.Definition.ImportCore(m, id, n, []); }

    / m:Meta import_ id:Name exposing_ b:NonemptyListOf<Binding, ","> ";"
      { new ast.Definition.ImportCore(m, id, null, b); }
    ;

  Binding
    = e:Name as_ l:Name       { new ast.ImportBinding.Alias(e, l); }
    / default_ as_ l:Name     { new ast.ImportBinding.Default(l); }
    / n:Name                  { new ast.ImportBinding.Alias(n, n); }
    ;

  Export
    = m:Meta export_ l:Name as_ e:Name ";"   { new ast.Definition.ExportLocal(m, l, e); }
    / m:Meta export_ n:Name ";"              { new ast.Definition.ExportLocal(m, n, n); }
    ;

  Function
    = m:Meta function_ s:FunctionSignature b:FunctionBody
      { new ast.Definition.Function(m, s.kind, s.name, s.parameters, b); }
    ;

  FunctionBody
    = "=" e:Expression ";"    { [new ast.Statement.Expression(e)]; }
    / b:Block                 { b; }
    ;

  FunctionSignature
    = t:FunctionType n:Name p:ParamList   { new Signature(t, n, p); }
    ;

  ParamList
    = "(" "..." n:Name ")"
      { new ast.Parameters.Spread([], n); }

    / "(" p:NonemptyListOf<ParamName, ","> "," "..." n:Name ")"
      { new ast.Parameters.Spread(p, n); }

    / "(" np:NonemptyListOf<NamedParam, ","> ")"
      { new ast.Parameters.Regular([], np); }

    / "(" p:NonemptyListOf<ParamName, ","> "," np:NonemptyListOf<NamedParam, ","> ")"
      { new ast.Parameters.Regular(p, np); }

    / "(" p:ListOf<ParamName, ","> ")"
      { new ast.Parameters.Regular(p, []); }
    ;

  ParamName
    = n:Name ~":"   { n; }
    ;

  NamedParam
    = k:Name ":" v:Name "=" e:Expression  { new ast.NamedParameter(k, v, e); }
    / k:Name ":" v:Name                   { new ast.NamedParameter(k, v, new ast.Literal.Null()); }
    ;

  FunctionType
    = t:FunctionType1?  { if t === null then new ast.FunctionKind.Regular() else t; }
    ;

  FunctionType1
    = "*"     { new ast.FunctionKind.Generator(); }
    / async_  { new ast.FunctionKind.Asynchronous(); }
    ;

  Module
    = m:Meta module_ n:Name "{" d:Definition* "}"   { new ast.Definition.Module(m, n, d); }
    ;

  Class
    = m:Meta data_ class_ n:Name c:ClassDeclaration
      { 
        new ast.Definition.Class(m, new ast.ClassKind.Data(), n, c); 
      }
    / m:Meta class_ n:Name c:ClassDeclaration         
      { 
        new ast.Definition.Class(m, new ast.ClassKind.Regular(), n, c); 
      }
    ;

  ClassDeclaration
    = p:ParamList s:SuperClass? "{" f:ClassField* b:Statement* m:ClassMember* "}"
      { new ast.ClassDeclaration(p, s, f, b, m); }
    ;

  SuperClass
    = extends_ o:MemberExpression a:ArgList   { new ast.Superclass(o, a); }
    ;

  ClassField
    = m:Meta field_ n:Name "=" e:Expression ";"   { new ast.ClassField(m, n, e); }
    ;

  ClassMember
    = m:Meta static_ d:MemberDeclaration    { new ast.ClassMember(m, new ast.MemberKind.Static(), d); }
    / m:Meta member_ d:MemberDeclaration    { new ast.ClassMember(m, new ast.MemberKind.Instance(), d); }
    ;

  MemberDeclaration
    = t:FunctionType s:Name "." m:Name p:ParamList b:MemberBlock
      { new ast.MemberDeclaration.Method(t, s, m, p, b); }

    / s:Name "." n:Name "<-" p:Name b:MemberBlock
      { new ast.MemberDeclaration.Setter(s, n, p, b); }
    
    / s:Name "." n:Name b:MemberBlock
      { new ast.MemberDeclaration.Getter(s, n, b); }

    / s:Name "[" k:Name "]" "<-" p:Name b:MemberBlock
      { new ast.MemberDeclaration.AtPut(s, k, p, b); }

    / s:Name "[" k:Name "]" b:MemberBlock
      { new ast.MemberDeclaration.At(s, k, b); }

    / p:Name in_ s:Name b:MemberBlock
      { new ast.MemberDeclaration.In(s, p, b); }

    / s:Name o:operator p:Name b:MemberBlock
      { new ast.MemberDeclaration.Binary(s, o, p, b); }

    / not_ s:Name b:MemberBlock
      { new ast.MemberDeclaration.Unary(s, "not", b); }
    ;

  MemberBlock = FunctionBody;

  Meta
    = c:doc_comment? d:Decorator*   { new ast.Metadata(c, d); }
    ;

  Decorator
    = "@" q:QualifiedName a:CompileTimeArgList  { new ast.Decorator(q, a); }
    / "@" q:QualifiedName                       { new ast.Decorator(q, []); }
    ;

  Block
    = "{" s:Statement* "}"    { s; }
    ;

  Statement
    = d:Decorator+ s:CommonStatement    { new ast.Statement.Decorated(d, s); }
    / CommonStatement
    ;

  CommonStatement
    = LetStatement
    / AssertStatement
    / LoopStatement
    / IfStatement
    / MatchStatement
    / e:Expression ";"    { new ast.Statement.Expression(e); }
    ;

  LetStatement
    = let_ mutable_ n:Name "=" e:Expression ";"   { new ast.Statement.LetMutable(n, e); }
    / let_ n:Name "=" e:Expression ";"            { new ast.Statement.Let(n, e); }
    / let_ p:Pattern "=" e:Expression ";"         { new ast.Statement.LetMatch(p, e); }
    ;

  AssertStatement
    = assert_ e:Expression ";"    { new ast.Statement.Assert(e); }
    ;

  LoopStatement
    = for_ each_ n:Name of_ e:Expression b:Block    { new ast.Statement.Foreach(n, e, b); }
    / repeat_ while_ e:Expression b:Block           { new ast.Statement.While(e, b); }
    / repeat_ until_ e:Expression b:Block           { new ast.Statement.Until(e, b); }

    / repeat_ with_ n:Name from_ s:Expression to_ e:Expression b:Block
      { 
        let one = new ast.Expression.Literal(new ast.Literal.Integer(new ast.Sign.Unsigned(), "1"));
        new ast.Statement.For(n, s, e, one, b); 
      }

    / repeat_ with_ n:Name from_ s:Expression to_ e:Expression by_ st:Expression b:Block
      { new ast.Statement.For(n, s, e, st, b); }
    
    / repeat_ b:Block   { new ast.Statement.Repeat(b); }
    ;

  IfStatement
    = if_ t:Expression b:Block a:AlternateStatement   { new ast.Statement.IfElse(t, b, a); }
    / if_ t:Expression b:Block                        { new ast.Statement.If(t, b); }
    ;

  AlternateStatement
    = else_ i:IfStatement   { new ast.Alternate.If(i); }
    / else_ b:Block         { new ast.Alternate.Else(b); }
    ;

  MatchStatement
    = match_ e:Expression "{" c:MatchCase* "}"    { new ast.Statement.Match(e, c); }
    ;

  MatchCase
    = case_ p:Pattern when_ t:Expression ":" b:Statement*   { new ast.MatchCase.When(p, t, b); }
    / case_ p:Pattern ":" b:Statement*                      { new ast.MatchCase.Case(p, b); }
    / default_ ":" b:Statement*                             { new ast.MatchCase.Default(b); }
    ;

  Pattern
    = l:Literal                                             { new ast.Pattern.Literal(l); }
    / "[" a:ArrayPattern "]"                                { new ast.Pattern.Array(a); }
    / "{" p:ListOf<PairPattern, ","> "}"                    { new ast.Pattern.Object(p); }
    / o:MemberExpression "(" p:ListOf<Pattern, ","> ")"     { new ast.Pattern.Extractor(o, p); }
    / n:Name                                                { new ast.Pattern.Bind(n); }
    ;

  ArrayPattern
    = h:NonemptyListOf<Pattern, ","> "," "..." t:Pattern    { new ast.ArrayPattern.Spread(h, t); }
    / "..." p:Pattern                                       { new ast.ArrayPattern.Spread([], p); }
    / p:ListOf<Pattern, ",">                                { new ast.ArrayPattern.Fixed(p); }
    ;

  PairPattern
    = n:Name ":" p:Pattern                                  { new ast.Pair(n, p); }
    ;

  Expression
    = d:Decorator+ e:CommonExpression                       { new ast.Expression.Decorated(d, e); }
    / CommonExpression
    ;
    
  CommonExpression
    = IfExpression
    / PipeExpression
    ;

  IfExpression
    = if_ t:Expression then_ c:Expression else_ a:Expression    { new ast.Expression.IfThenElse(t, c, a); }
    ;

  PipeExpression
    = l:PipeExpression "|>" r:BinaryExpression                  { new ast.Expression.Pipe(l, r); }
    / YieldAwait
    ;

  YieldAwait
    = await_ e:SendExpression                                 { new ast.Expression.Await(e); }
    / yield_ "*" e:SendExpression                             { new ast.Expression.YieldAll(e); }
    / yield_ e:SendExpression                                 { new ast.Expression.Yield(e); }
    / BinaryExpression
    ;

  BinaryExpression
    = l:UnaryExpression t:BinaryExpressionTrail<and_>+    { binaryL(l, t); }
    / l:UnaryExpression t:BinaryExpressionTrail<or_>+     { binaryL(l, t); }
    / not_ e:UnaryExpression                              { new ast.Expression.Unary("not", e); }

    / l:UnaryExpression t:BinaryExpressionTrail<"++">+    { binaryL(l, t); }
    
    / l:UnaryExpression t:BinaryExpressionTrail<">>">+    { binaryL(l, t); }
    / l:UnaryExpression t:BinaryExpressionTrail<"<<">+    { binaryL(l, t); }

    / v:UnaryExpression in_ o:UnaryExpression             { new ast.Expression.In(o, v); }
    
    / l:UnaryExpression "->" r:UnaryExpression            { new ast.Expression.Binary("->", l, r); }

    / l:UnaryExpression t:BinaryExpressionTrail<"+">+     { binaryL(l, t); }
    / l:UnaryExpression "**" r:UnaryExpression            { new ast.Expression.Binary("**", l, r); }
    / l:UnaryExpression t:BinaryExpressionTrail<"*">+     { binaryL(l, t); }
    / l:UnaryExpression "-" r:UnaryExpression             { new ast.Expression.Binary("-", l, r); }
    / l:UnaryExpression "/" r:UnaryExpression             { new ast.Expression.Binary("/", l, r); }
    
    / l:UnaryExpression "===" r:UnaryExpression           { new ast.Expression.Binary("===", l, r); }
    / l:UnaryExpression "=/=" r:UnaryExpression           { new ast.Expression.Binary("=/=", l, r); }
    / l:UnaryExpression ">=" r:UnaryExpression            { new ast.Expression.Binary(">=", l, r); }
    / l:UnaryExpression "<=" r:UnaryExpression            { new ast.Expression.Binary("<=", l, r); }
    / l:UnaryExpression ">" r:UnaryExpression             { new ast.Expression.Binary(">", l, r); }
    / l:UnaryExpression "<" r:UnaryExpression             { new ast.Expression.Binary("<", l, r); }
    / UnaryExpression
    ;

  BinaryExpressionTrail<operator>
    = op:operator e:UnaryExpression   { { operator: op, expression: e }; }
    ;

  UnaryExpression
    = SendExpression;

  SendExpression
    = s:SendExpression k:SendContinuation   { k(s); }
    / AssignExpression
    ;

  SendContinuation
    = a:ArgList                                     { (x) => new ast.Expression.Call(x, a); }
    / "." m:Name a:ArgList                          { (x) => new ast.Expression.MethodCall(x, m, a); }
    / "[" k:Expression "]" "<-" v:Expression        { (x) => new ast.Expression.AtPut(x, k, v); }
    / "[" k:Expression "]"                          { (x) => new ast.Expression.At(x, k); }
    / "." n:Name "<-" v:Expression                  { (x) => new ast.Expression.Set(x, n, v); }
    / "." n:Name                                    { (x) => new ast.Expression.Get(x, n); }
    ;

  AssignExpression
    = m:MemberExpression "<-" e:Expression
      {
        match m {
          case ast.Expression.Get(o, p):   new ast.Expression.Set(o, p, e);
          case ast.Expression.At(o, k):    new ast.Expression.AtPut(o, k, e);
          case ast.Expression.Variable(n): new ast.Expression.Assign(m, e);
          // TODO: anything else isn't an L-Value
        }
      }
    / MemberExpression
    ;

  MemberExpression
    = m:MemberExpression "[" k:Expression "]"   { new ast.Expression.At(m, k); }
    / m:MemberExpression "." n:Name             { new ast.Expression.Get(m, n); }
    / NewExpression
    ;

  NewExpression
    = new_ m:MemberExpression a:ArgList         { new ast.Expression.New(m, a); }
    / PrimaryExpression
    ;

  PrimaryExpression
    = ~reserved_var n:Name ~":"                 { new ast.Expression.Variable(n); }
    / super_                                    { new ast.Expression.Super(); }
    / "_"                                       { new ast.Expression.Hole(); }
    / l:Literal                                 { new ast.Expression.Literal(l); }
    / ArrayExpression
    / ObjectExpression
    / FunctionExpression
    / ClassExpression
    / "(" e:Expression ")"                      { e; }
    ;

  ClassExpression
    = c:Class   { new ast.Expression.Class(c); }
    ;

  ArrayExpression
    = "[" xs:ListOf<ArrayItem, ","> "]"         { new ast.Expression.Array(xs); }
    ;

  ArrayItem
    = "..." e:Expression                        { new ast.ArrayItem.Spread(e); }
    / e:Expression                              { new ast.ArrayItem.Element(e); }
    ;

  ObjectExpression
    = "{" p:ListOf<Pair, ","> "}"               { new ast.Expression.Object(p); }
    ;

  FunctionExpression
    = t:FunctionType p:ParamList "=>" b:Block         
      { new ast.Expression.Function(t, p, b); }

    / t:FunctionType p:ParamList "=>" e:Expression    
      { new ast.Expression.Function(t, p, [new ast.Statement.Expression(e)]); }
    ;

  Literal
    = String
    / Boolean
    / Decimal
    / Integer
    / null_     { new ast.Literal.Null(); }
    ;

  String = string;
  Boolean = boolean;
  Decimal = decimal;
  Integer = integer;

  ArgList
    = "(" x:ListOf<Argument, ","> ")"     
      {
        let positional = x.filter((x, _, _) => not (x is ast.Argument.Named)) ;
        let named = x.filter((x, _, _) => x is ast.Argument.Named);
        new ast.Arguments(positional, named);
      }
    ;

  Argument
    = "..." e:Expression                  { new ast.Argument.Spread(e); }
    / n:Name ":" e:Expression             { new ast.Argument.Named(n, e); }
    / e:Expression                        { new ast.Argument.Positional(e); }
    ;

  CompileTimeArgList
    = "(" x:ListOf<CompileTimeArg, ","> ")"   { x; }
    ;

  CompileTimeArg
    = "[" x:ListOf<CompileTimeArg, ","> "]"   { new ast.MacroLiteral.Array(x); }
    / "{" x:ListOf<CompileTimePair, ","> "}"  { new ast.MacroLiteral.Object(x); }
    / l:Literal                               { new ast.MacroLiteral.Literal(l); }
    ;

  CompileTimePair
    = n:Name ":" e:CompileTimeArg   { new ast.Pair(n, e); }
    ;

  Pair
    = n:Name ":" e:Expression             { new ast.Pair(n, e); }
    ;

  Name
    = ~reserved n:id                      { n; }
    ;

  QualifiedName
    = x:NonemptyListOf<Name, ".">         { x; }
    ;

  //-- LEXICAL --------------------------------------------------------
  newline = "\n" / "\r";
  line = (~newline any)*;
  comment = "//" line;
  doc_comment = "/*" (~"*/" any)* "*/";
  space += comment;

  id_start = letter / "_";
  id_rest = id_start / digit;
  id = id_start id_rest*;

  kw<word> = word ~id_rest;
  reserved_var = "_" ~id_rest;

  operator 
    = "===" / "=/="
    / ">="  / ">>"  / ">"
    / "<="  / "<<"  / "<"
    / "++"  / "+"
    / "->"  / "-"
    / "**"  / "*"
    / "/"
    / and_  / or_;


  octal_digit = "0" .. "7" / "_";
  hex_digit = raw_hex_digit / "_";
  raw_hex_digit = "0" .. "9" / "a" .. "f" / "A" .. "F";
  bin_digit = "0" / "1" / "_";
  decimal_digit = "0" .. "9" / "_";

  integral_number 
    = "0o" d:octal_digit+       { String(parseInt(fixDigits(d), 8)); }
    / "0x" d:hex_digit+         { String(parseInt(fixDigits(d), 16)); }
    / "0b" d:bin_digit+         { String(parseInt(fixDigits(d), 2)); }
    / ~"_" d:decimal_digit+     { fixDigits(d); }
    ;

  raw_character 
    = ~"\"\"\"" any;

  escape_sequence
    = "b"                   { "\b"; }
    / "f"                   { "\f"; }
    / "n"                   { "\n"; }
    / "r"                   { "\r"; }
    / "t"                   { "\t"; }
    / "u" e:unicode_escape  { String.fromCodePoint(parseInt(e, 16)); }
    / "\""                  { "\""; }
    / "\\"                  { "\\"; }
    ;

  string_character
    = ~("\"" / "\\") any
    / "\\" e:escape_sequence   { e; }
    ;

  unicode_escape 
    = raw_hex_digit raw_hex_digit raw_hex_digit raw_hex_digit
    ;

  string
    = "\"\"\"" cs:raw_character* "\"\"\""       { cs.join(""); }
    / "\"" cs:string_character* "\""            { cs.join(""); }
    ;
  
  integer
    = "-" i:integral_number   { new ast.Literal.Integer(new ast.Sign.Negative(), i); }
    / "+" i:integral_number   { new ast.Literal.Integer(new ast.Sign.Positive(), i); }
    / i:integral_number       { new ast.Literal.Integer(new ast.Sign.Unsigned(), i); }
    ;

  decimal
    = "-" i:decimal_digit+ "." d:decimal_digit+
      { new ast.Literal.Decimal(new ast.Sign.Negative(), fixDigits(i), fixDigits(d)); }
    
    / "+" i:decimal_digit+ "." d:decimal_digit+
      { new ast.Literal.Decimal(new ast.Sign.Positive(), fixDigits(i), fixDigits(d)); }

    / ~ "_" i:decimal_digit+ "." d:decimal_digit+
      { new ast.Literal.Decimal(new ast.Sign.Unsigned(), fixDigits(i), fixDigits(d)); }
    ;
  
  boolean
    = true_    { new ast.Literal.Boolean(true); }
    / false_   { new ast.Literal.Boolean(false); }
    ;


  import_ = kw<"import">;
  exposing_ = kw<"exposing">;
  as_ = kw<"as">;

  function_ = kw<"function">;
  async_ = kw<"async">;

  data_ = kw<"data">;
  class_ = kw<"class">;
  abstract_ = kw<"abstract">;
  extends_ = kw<"extends">;
  static_ = kw<"static">;
  member_ = kw<"member">;
  field_ = kw<"field">;

  let_ = kw<"let">;
  mutable_ = kw<"mutable">;

  assert_ = kw<"assert">;

  if_ = kw<"if">;
  then_ = kw<"then">;
  else_ = kw<"else">;

  and_ = kw<"and">;
  or_ = kw<"or">;
  not_ = kw<"not">;
  
  await_ = kw<"await">;
  yield_ = kw<"yield">;

  new_ = kw<"new">;
  super_ = kw<"super">;

  for_ = kw<"for">;
  each_ = kw<"each">;
  of_ = kw<"of">;
  repeat_ = kw<"repeat">;
  with_ = kw<"with">;
  while_ = kw<"while">;
  until_ = kw<"until">;
  from_ = kw<"from">;
  to_ = kw<"to">;
  by_ = kw<"by">;

  true_ = kw<"true">;
  false_ = kw<"false">;

  try_ = kw<"try">;
  finally_ = kw<"finally">;
  catch_ = kw<"catch">;

  match_ = kw<"match">;
  case_ = kw<"case">;
  when_ = kw<"when">;
  default_ = kw<"default">;

  null_ = kw<"null">;

  module_ = kw<"module">;
  export_ = kw<"export">;

  in_ = kw<"in">;


  reserved
    = abstract_ / and_ / assert_ / async_ / as_ / await_
    / by_
    / case_ / catch_ / class_
    / data_ / default_
    / each_ / else_ / export_ / exposing_ / extends_
    / false_ / field_ / finally_ / for_ / from_ / function_
    / if_ / import_ / in_
    / let_
    / match_ / member_ / module_ / mutable_
    / new_ / not_ / null_
    / of_ / or_
    / repeat_
    / static_ / super_
    / then_ / to_ / true_ / try_
    / until_
    / with_ / when_ / while_
    / yield_;
}
  """;

  function parse(source) {
    grammar.parse(source);
  }
}