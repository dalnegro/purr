% language: origami

/* Represents an Origami compilation unit/file. */
data class File(header, definitions) {}

/* Represents any key/value pair that may occurr in the grammar. */
data class Pair(key, value) {}

/* Represents metadata */
data class Metadata(documentation, decorators) {}

/* Represents a decorator */
data class Decorator(id, args) {}


// -- Modules and top-level -------------------------------------------
/* Top-level definitions */
module Definition {
  /* An import of an user-land/Node module package. */
  data class Import(meta, id, alias, bindings) {}
  /* An import of special host/specification modules */
  data class ImportCore(meta, name, alias, bindings) {}
  /* An export of a local name */
  data class ExportLocal(meta, name, alias) {}
  /* A definition of a function */
  data class Function(meta, kind, name, parameters, body) {}
  /* A definition of a class */
  data class Class(meta, kind, name, classDeclaration) {}
  /* A definition of an inner module */
  data class Module(meta, name, definitions) {}

  // FIXME: this should probably be way more restricted
  /* A top-level statement */
  data class Statement(statement) {}
}

/* Types of bindings */
module ImportBinding {
  data class Alias(name, local) {}
  data class Default(local) {}
}


// -- Classes ---------------------------------------------------------
/* Possible types of classes */
module ClassKind {
  data class Regular() {}
  data class Data() {}
}

/* Class declaration (which can be shared with different contexts) */
data class ClassDeclaration(parameters, superclass, fields, ctor, members) {}

/* A superclass definition */
data class Superclass(ctor, args) {}

/* A field in a class */
data class ClassField(meta, name, initializer) {}

/* A method in a class */
data class ClassMember(meta, kind, declaration) {}

/* Where a member should be attached */
module MemberKind {
  data class Static() {}
  data class Instance() {}
}

/* What kind of class method a member is */
module MemberDeclaration {
  data class Method(kind, self, name, parameters, body) {}
  data class Setter(self, name, parameter, body) {}
  data class Getter(self, name, body) {}
  data class AtPut(self, key, value, body) {}
  data class At(self, key, body) {}
  data class In(self, value, body) {}
  data class Binary(self, operator, right, body) {}
  data class Unary(self, operator, body) {}
}

// -- Functions and other parameterisable definitions -----------------
/* Represents a named parameter */
data class NamedParameter(key, value, initializer) {}

/* Possible kinds of functions */
module FunctionKind {
  data class Regular() {}
  data class Asynchronous() {}
  data class Generator() {}
}

/* Possible kinds of parameters for parameterised definitions */
module Parameters {
  data class Spread(positional, spread) {}
  data class Regular(positional, named) {}
}


// -- Statements and expressions --------------------------------------
/* The statement sub-language */
module Statement {
  data class Let(name, initializer) {}
  data class LetMutable(name, initializer) {}
  data class LetMatch(pattern, initializer) {}
  data class Assert(expression) {}
  data class Foreach(name, expression, body) {}
  data class While(predicate, body) {}
  data class Until(predicate, body) {}
  data class For(name, start, end, step, body) {}
  data class Repeat(body) {}
  data class IfElse(test, consequent, alternate) {}
  data class If(test, consequent) {}
  data class Match(expression, cases) {}
  data class Expression(expression) {}
  data class Decorated(decorators, statement) {}
}

/* Possible braces of an If-statement */
module Alternate {
  data class If(ifStatement) {}
  data class Else(block) {}
}

/* The expression sub-language */
module Expression {
  data class IfThenElse(test, consequent, alternate) {}
  data class Pipe(left, right) {}
  data class Await(expression) {}
  data class YieldAll(expression) {}
  data class Yield(expression) {}
  data class Binary(operator, left, right) {}
  data class In(object, value) {}
  data class Unary(operator, expression) {}
  data class Call(callee, args) {}
  data class MethodCall(object, message, args) {}
  data class Set(object, property, value) {}
  data class Get(object, property) {}
  data class At(object, key) {}
  data class AtPut(object, key, value) {}
  data class Assign(name, value) {}
  data class New(object, args) {}
  data class Variable(name) {}
  data class Super() {}
  data class Literal(literal) {}
  data class Hole() {}
  data class Array(items) {}
  data class Object(pairs) {}
  data class Function(kind, parameters, body) {}
  data class Class(classDefinition) {}
  data class Decorated(decorators, expression) {}
}

/* Items in an array expression */
module ArrayItem {
  data class Spread(expression) {}
  data class Element(expression) {}
}

/* Kinds of arguments */
module Argument {
  data class Positional(expression) {}
  data class Named(name, expression) {}
  data class Spread(expression) {}
}

/* The arguments for a function call */
data class Arguments(positional, named) {}


// -- Pattern matching ------------------------------------------------
/* Types of cases in a match */
module MatchCase {
  data class When(pattern, predicate, body) {}
  data class Case(pattern, body) {}
  data class Default(body) {}
}

/* Types of pattern to match */
module Pattern {
  data class Literal(literal) {}
  data class Array(items) {}
  data class Object(pairs) {}
  data class Extractor(object, patterns) {}   // TODO: how do Extractors interact with named args?
  data class Bind(name) {}
}

/* Array patterns can have or not a spread */
module ArrayPattern {
  data class Spread(items, spread) {}
  data class Fixed(items) {}
}

// -- Literals --------------------------------------------------------
/* Types of literals */
module Literal {
  data class String(value) {}
  data class Boolean(value) {}
  data class Decimal(sign, integer, decimal) {}
  data class Integer(sign, digits) {}
  data class Null() {}
}

/* An extended set of literals for compile-time programming */
module MacroLiteral {
  data class Literal(literal) {}
  data class Array(items) {}
  data class Object(pairs) {}
}

/* The sign of a number literal */
module Sign {
  data class Positive() {}
  data class Negative() {}
  data class Unsigned() {}
}